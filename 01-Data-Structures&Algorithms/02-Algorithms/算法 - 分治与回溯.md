# 分治

## 基本概念

**分治算法（divide and conquer）**和核心思想正如其字面含义，**分而治之**，就是把一个复杂问题分成**两个或者更多**的相同和相似的问题，直到最后问题可以简单的直接求解，原问题的解即是子问题解的合并。

这个定义看起来类似递归的定义，区别在于**分治算法是一种处理问题的思想，而递归是一种编程技巧**。实际上，**分治算法一般比较适合用递归来实现，当然也可以用迭代来实现**，这也是区别之一。递归算法从本质上来就是分治算法，无非就是有些问题递归需要将原问题分解成多个子问题，而有的只需要分解成一个子问题，前者为分治，后者即为递归。

分治算法能解决的问题一般满足下面几个条件：

* 分解（Divide）：将原问题分解成若干个子问题。
* 解决（Conquer）：分解的子问题足够小并可以**独立**求解的话，就直接求解。
* 合并（Merge）：将子问题的解合并，形成原问题的解。（这个合并操作的复杂度不易过高）

> 分治算法一般体现在`归并排序`和`快速排序`里面。

## 经典举例

以[剑指 Offer 51. 数组中的逆序对](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/)为例，如果数组中的两个数字，前面一个数字大于后面的数字，则这两个数字组成一个逆序对。

例如数组[7,5,6,4]，其逆序对有`(7,5)，(7,6)，(7,4)，(5,4)，(6,4)`，逆序数为`3+1+1=5`。正如这里罗列的一样，暴力解法即拿每个数字跟它后面的数字比较，统计比它小的数记着`k`。`n`个元素就有对应的`n`个逆序数`k`，然后求这`n`个`k`之和。这样操作的时间复杂度为O(n^2^)。有没有更加高效的处理方法呢？

这里，可以采用分治的思想来解决问题。先把数组分成前后两个部分`leftPart`与`rightPart`，分别计算`leftPart`与`rightPart`对应逆序对数`k1`与`k2`，然后再计算 `leftPart` 与 `rightPart` 之间的逆序对个数 `K3`。那么总的逆序数为`k1+k2+k3`了。这样，通过分治把问题分解成独立子问题直接求解，最后再合并子问题的解。

为保证合并的操作复杂度不高，可以采用`归并排序算法`来解决。归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。如下图所示，为数组 [7, 3, 2, 6, 0, 1, 5, 4]的归并排序过程。

<img src="..\..\images\algorithms\逆序对.png" alt="img" style="zoom: 33%;" />

**合并阶段本质上是合并两个排序数组的过程**，而每当遇到 左子数组当前元素 > 右子数组当前元素 时，意味着 「左子数组当前元素 至 末尾元素」 与 「右子数组当前元素」 构成了若干 「逆序对」 。

```java
    public int reversePairs(int[] nums) {
        if (nums.length < 2) 
            return 0;
        int[] tmp = new int[nums.length];// 临时数组用于归并
        return mergeSort(nums, tmp, 0, nums.length - 1);
    }

    public int mergeSort(int[] nums, int[] tmp, int left, int right) {
        // 终止条件,子数组长度为1，停止划分
        if (left >= right) 
            return 0;
        // 递归划分左子数组与右子数组
        int mid = left + right >>> 1;
        int res = mergeSort(nums, tmp, left, mid) + mergeSort(nums, tmp, mid + 1, right);
        //  合并阶段 idx为临时数组的移动指针
        int i = left, j = mid + 1, idx = left, count = 0;
        // 左右两数组都还剩有数字未排序时
        while (i <= mid && j <= right) {
            if (nums[i] > nums[j]) {
                tmp[idx++] = nums[j];
                count = j - mid; // 统计j->mid 之间，比nums[i]小的元素个数
                j++;
            } else {
                tmp[idx++] = nums[i];
                res += count;
                i++;
            }
        }
        // 左右两数组有一边已经移动完毕，剩下另一边可进行快速移动
        while (i <= mid) {
            tmp[idx++] = nums[i];
            res += count;
            i++;
        }
        
        while (j <= right) 
            tmp[idx++] = nums[j++];

        // 将tep中的数还原回原nums中
        for (int k = left; k <= right; ++k)
            nums[k] = tmp[k];
        
        return res;
    }
```

更好理解的写法：

```java
    public int reversePairs(int[] nums) {
        if (nums == null || nums.length < 2)
            return 0;
        int[] tmp = new int[nums.length];// 临时数组用于归并
        return mergeSort(nums, tmp, 0, nums.length - 1);
    }
 
    public int mergeSort(int[] nums, int[] tmp, int left, int right) {
        if (left == right) // 终止条件,子数组长度为1，停止划分
            return 0;
        int mid = left + (right - left >>> 1);
        // 递归划分左子数组与右子数组
        return mergeSort(nums, tmp, left, mid) 
            + mergeSort(nums, tmp, mid + 1, right) 
            + mergeCross(nums, tmp, left, mid, right);
    }
	// 合并阶段
    public int mergeCross(int[] nums, int[] tmp, int left, int mid, int right) {
        // pos待归并数组的起始位置
        int pos = 0, i = left, j = mid + 1, res = 0;
		// 左右两个子区间都未遍历完
        while (i <= mid && j <= right) {
            res += nums[i] <= nums[j] ? 0 : mid - i + 1;
            tmp[pos++] = nums[i] <= nums[j] ? nums[i++] : nums[j++];
        }
        // 左半部分元素有剩余
        while (i <= mid)
            tmp[pos++] = nums[i++];
		// 右半部分元素有剩余
        while (j <= right) 
            tmp[pos++] = nums[j++];
        // 用临时数组tmp赋值回numsk
        for (int k = left; k <= right; k++) {
            nums[k] = tmp[i - left];
        }
        return res;
    }
```

> 时间复杂度：O(nlog n)，空间复杂度：O(n)

# 回溯

## 基本概念

**回溯法（Backtracking）**采用试错的思想，它尝试分步去解决一个问题。在分步解决问题的过程中，它通过尝试发现现有的分布答案不能得到有效的正确的解答的时候，它将取消上一步甚至上几步的计算，再通过其他的的可能的分布解答再次尝试寻找问题的答案。

回溯法通常使用最简单的递归方法实现。在反反复复上述的步骤后可能出现两种情况：

* 找到一个可能存在的正确答案；
* 在尝试了所有可能的分步方法后宣告该问题没有答案。

在最坏的情况下，回溯法会导致一次复杂度为指数时间的计算。

回溯算法的特征：

* 回溯算法一般采用深度优先搜索求解，因此满足递归的一般特征。
* 子集：回溯题目一般都要求求解所有的最优解，因此，dfs的`终止条件就是判断是否得到了一个最优解`，然后直接返回。
* 遍历空间集：在每一轮dfs中都需要遍历空间集，根据题目性质，有的需要`从0开始`，有的需要`从当前位置开始`。
* 剪枝：在遍历空间集的时候，需要`优先将不符合条件的去除掉`，不然会做很多无用的递归调用，导致超时。
* 加入元素：遍历空间集的时候，加入每一个元素，然后再dfs。
* 移除元素：当一轮dfs达到终止条件结束的时候，说明当前选择已经完成，需要`返回到上一轮做其他选择`，因此需要`将上一轮选择时加入的元素删除掉`。

## 经典举例

例一：[组合总和](https://leetcode-cn.com/problems/combination-sum/submissions/)

分支污染：https://leetcode-cn.com/problems/combination-sum/

# 参考

* [剑指 Offer 51. 数组中的逆序对（归并排序，清晰图解）](https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/jian-zhi-offer-51-shu-zu-zhong-de-ni-xu-pvn2h/)
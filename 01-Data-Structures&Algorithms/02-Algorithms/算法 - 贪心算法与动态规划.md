# 贪心算法

## 基本概念

**贪心算法（Greedy）**是在每一步选择中都采取在当前状态下最好或者最优（即最有利的）选择，从而希望导致结果是全局最好或最优的算法（实际上考虑的是局部最优解）。

适用贪心算法的场景：**局部最优策略能导致产生全局最优解**。当问题能够分解成子问题解决，并且**每个子问题的最优解**能递推到最终问题的最优解（这种子问题最优解被称为**最优子结构**）。

## 经典举例

### 教室调度

以《算法图解》中教室调度为例，如果有课程表如下，希望尽可能多地安排教室。

| 课程   | 开始时间 | 结束时间 |
| ------ | -------- | -------- |
| 美术   | 9 AM     | 10 AM    |
| 英语   | 9:30 AM  | 10:30 AM |
| 数学   | 10 AM    | 11 AM    |
| 计算机 | 10:30 AM | 11:30 AM |
| 音乐   | 11 AM    | 12 AM    |

这个问题好像很难，实际上，算法可能简单得让你大吃一惊。具体做法如下。

* 选出结束最早的课，它就是要在这间教室上的第一堂课。
* 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要 在这间教室上的第二堂课。

美术课的结束时间最早，为10:00 AM，因此它 就是第一堂课。接下来的课必须在10:00 AM后开始，且结束得最早，那么再选择数学课；最后，计算机课与数学课的 时间是冲突的，但音乐课可以。最终课程安排就是`美术->数学->音乐`。

### 跳跃游戏

再以[LeetCode 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)为例，给定一个非负整数数组 `nums` ，玩家最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。判断是否能够到达最后一个下标。

当`nums = [2,3,1,1,4]`时，玩家位于下标0处，那么玩家可以第一步跳1格，然后再跳3格到达终点。当然，玩家第一步也可以最大跳2格，然后跳1格，再跳1格到终点。

由题可以分析出，对于每一个可以到达的位置 n，它使得 `n+1, n+2,⋯,n+nums[n]` 这些连续的位置也都可以到达。运用贪心算法的思想，我们依次遍历数组中每个位置并实时维护 **最远可以到达的位置**。在遍历的过程中，如果 **最远可以到达的位置** 大于等于数组中的最后一个位置，那就说明最后一个位置可达。

```java
    public boolean canJump(int[] nums) {
        int max = 0;							
        for(int i = 0;i < nums.length; i++) 
            if(i > max)
                return false;
            max = Math.max(nums[i] + i, max);
        }
        return true;
    } 
```

其实也可以逆向思考，从数组的倒数第二位开始计算，如果当前的位置加上当前所能跳转的最大距离大于等于last，说明这一步跳转是没问题的从最终位置先跳到上一可达位置，那么更新最终位置，直到最终位置与起始点重合，那么证明可达。

```java
    public boolean canJump(int[] nums) {
        int last = nums.length - 1;
        for (int i = last; i >= 0; i--) {
            if (nums[i] + i >= last) 
                last = i;
        }
        return last == 0;
    }
```

# 动态规划

## 基本概念

### “一个模型三个特征”理论

什么样的问题适合用动态规划来解决呢？换句话说，动态规划能解决的问题有什么规律可循呢？实际上，动态规划作为一个非常成熟的算法思想，很多人对此已经做了非常全面的总结。这里把这部分理论总结为“**一个模型三个特征**”。

首先来看，什么是“**一个模型**”？它指的是动态规划适合解决的问题的模型。把这个模型定义为“**多阶段决策最优解模型**”。下面具体来讲讲。

一般是用动态规划来解决最优问题。而解决问题的过程，需要经历多个决策阶段。每个决策阶段都对应着一组状态。然后寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。

现在再来看，什么是“**三个特征**”？它们分别是**最优子结构**、**无后效性**和**重复子问题**。这三个概念比较抽象，下面来逐一详细解释一下。

### 1. 最优子结构

最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，可以通过子问题的最优解，推导出问题的最优解。如果把最优子结构，对应到前面定义的动态规划问题模型上，那也可以理解为，后面阶段的状态可以通过前面阶段的状态推导出来。

### 2. 无后效性

无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性。

### 3. 重复子问题

这个概念比较好理解。前面已经多次提过。如果用一句话概括一下，那就是，不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

> 贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前运算结果，并根据以前的结果对当前进行选择，有回退功能。

## 经典举例

# 参考
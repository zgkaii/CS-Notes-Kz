### 2.3 MAT与JProfiler的GC Roots溯源

**使用JVIsualVM**

捕获的heap dump文件是一个临时文件，关闭JVisualVM后自动删除，若要保留，需要将其另存为文件。可通过以下方法捕获heap dump：

在左侧“Application"（应用程序）子窗口中右击相应的应用程序，选择Heap Dump（堆Dump）。

在Monitor（监视）子标签页中点击Heap Dump（堆Dump）按钮。本地应用程序的Heap dumps作为应用程序标签页的一个子标签页打开。同时，heap dump在左侧的Application（应用程序）栏中对应一个含有时间戳的节点。

右击这个节点选择save as（另存为）即可将heap dump保存到本地。

**使用MAT打开Dump文件**

MAT是Memory Analyzer的简称，它是一款功能强大的Java堆内存分析器。用于查找内存泄漏以及查看内存消耗情况。

打开后，我们就可以看到有哪些可以作为GC Roots的对象

<img src="https://img-blog.csdnimg.cn/20201014215008110.png" style="zoom:80%;" />

里面我们能够看到有一些常用的Java类，然后Thread线程。

**JProfiler的GC Roots溯源**

我们在实际的开发中，一般不会查找全部的GC Roots，可能只是查找某个对象的整个链路，或者称为GC Roots溯源，这个时候，我们就可以使用JProfiler。

![](https://img-blog.csdnimg.cn/20201014215633742.png)

**使用JProfiler分析OOM**

当我们程序出现OOM的时候，我们就需要进行排查：

```java
/**
 * 内存溢出排查
 * -Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError
 */
public class HeapOOM {
    // 创建1M的文件
    byte [] buffer = new byte[1 * 1024 * 1024];

    public static void main(String[] args) {
        ArrayList<HeapOOM> list = new ArrayList<>();
        int count = 0;
        try {
            while (true) {
                list.add(new HeapOOM());
                count++;
            }
        } catch (Exception e) {
            e.getStackTrace();
            System.out.println("count:" + count);
        }
    }
}
```

上述代码就是不断的创建一个1M小字节数组，然后让内存溢出，我们需要限制一下内存大小，同时使用`HeapDumpOnOutOfMemoryError`将出错时候的dump文件输出

```java
-Xms8m -Xmx8m -XX:+HeapDumpOnOutOfMemoryError
```

我们将生成的dump文件打开，然后点击Biggest Objects就能够看到超大对象：

![](https://img-blog.csdnimg.cn/20201014220134709.png)

通过线程，定位出现OOM位置：

![](https://img-blog.csdnimg.cn/20201014220408673.png)
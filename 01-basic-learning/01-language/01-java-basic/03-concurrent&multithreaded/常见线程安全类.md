## 3 常见线程安全类

* String

* Integer

* StringBuffer

* Random

* Vector

* Hashtable

* `java.util.concurrent` 包下的类

这里说它们是线程安全的是指，<span style ="color:red">多个线程调用它们同一个实例的某个方法时，是线程安全的</span>。也可以理解为它们的每个方法是原子的，但注意它们多个方法的组合不是原子的，如下：

```java
Hashtable table = new Hashtable();
// 线程1，线程2
if( table.get("key") == null) {
 table.put("key", value);
}
```

![](https://img-blog.csdnimg.cn/20201025221943824.png)

#### 3.1 不可变类的线程安全

`String`和`Integer`类都是不可变的类，因为其类内部状态是不可改变的，所以它们的方法都是线程安全的。有疑问的是，`String` 中 `replace`、`substring` 等方法可以改变值，为什么还是线程安全的呢？

其实调用这些方法返回的已经是一个新创建的对象了！

```java
public class Immutable {
    private int value = 0;

    public Immutable(int value) {
        this.value = value;
    }

    public int getValue() {
        return this.value;
    }

    public Immutable add(int v) {
        return new Immutable(this.value + v);
    }
}
```

#### 3.2 示例分析

**示例1**：

```java
public class MyServlet extends HttpServlet {
    // 是否安全？否
    Map<String,Object> map = new HashMap<>();
    // 是否安全？是
    String S1 = "...";
    // 是否安全？是
    final String S2 = "...";
    // 是否安全？不是
    Date D1 = new Date();
    // 是否安全？否
    final Date D2 = new Date();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        // 使用上述变量
    }
}
```

**示例2**：

```java
public class MyServlet extends HttpServlet {
    // 是否安全？否
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}

public class UserServiceImpl implements UserService {
    // 记录调用次数
    private int count = 0;

    public void update() {
        // 临界区
        count++;
    }
}
```

**示例3**：

分析线程是否安全，先对类的成员变量、类变量、局部变量进行考虑，如果变量会在各个线程之间共享，那么就得考虑线程安全问题；如果变量引用的是线程安全类的实例，并且只调用该线程安全类的一个方法，那么该变量是线程安全的的。

```java
@Aspect
@Component
public class MyAspect {
    // 是否安全？否。MyAspect切面类只有一个实例，成员变量start会被多个线程同时进行读写操作。
    private long start = 0L;

    @Before("execution(* *(..))")
    public void before() {
        start = System.nanoTime();
    }

    @After("execution(* *(..))")
    public void after() {
        long end = System.nanoTime();
        System.out.println("cost time:" + (end - start));
    }
}
```

**示例4**：

此例是典型的三层模型调用，`MyServlet`、 `UserServiceImpl` 、`UserDaoImpl`类都只有一个实例。

```java
public class MyServlet extends HttpServlet {
    // 是否安全？是。
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}

public class UserServiceImpl implements UserService {
    // 是否安全？是。UserServiceImpl类中只有一个线程安全的UserDaoImpl类的实例，那么UserServiceImpl类也是线程安全的。
    private UserDao userDao = new UserDaoImpl();

    public void update() {
        userDao.update();
    }
}

public class UserDaoImpl implements UserDao {
    public void update() {
        String sql = "update user set password = ? where username = ?";
        // 是否安全？是。UserDaoImpl类中没有成员变量，update方法里的变量引用的对象不是线程共享的。
        try (Connection conn = DriverManager.getConnection("", "", "")) {
            // ...
        } catch (Exception e) {
            // ...
        }
    }
}
```

**示例5**：

```java
public class MyServlet extends HttpServlet {
    // 是否安全？否。
    private UserService userService = new UserServiceImpl();

    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全？否。
    private UserDao userDao = new UserDaoImpl();
    public void update() {
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全？否。UserDaoImpl类中有成员变量，那么多个线程可以对成员变量conn同时进行操作，故是不安全的。
    private Connection conn = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```

**示例6**：

```java
public class MyServlet extends HttpServlet {
    // 是否安全？是
    private UserService userService = new UserServiceImpl();
    public void doGet(HttpServletRequest request, HttpServletResponse response) {
        userService.update(...);
    }
}
public class UserServiceImpl implements UserService {
    // 是否安全？是。UserServiceImpl类的update方法中UserDao是作为局部变量存在的，所以每个线程访问的时候都会新建一个		
    // UserDao对象，新建的对象是线程私有的，所以是线程安全的。
    public void update() {
        UserDao userDao = new UserDaoImpl();
        userDao.update();
    }
}
public class UserDaoImpl implements UserDao {
    // 是否安全？是。
    private Connection = null;
    public void update() throws SQLException {
        String sql = "update user set password = ? where username = ?";
        conn = DriverManager.getConnection("","","");
        // ...
        conn.close();
    }
}
```

**示例7**：

```java
public abstract class Test {
    public void bar() {
        // 是否安全？不确定，
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        foo(sdf);
    }

    public abstract foo(SimpleDateFormat sdf);

    public static void main(String[] args) {
        new Test().bar();
    }
}
```

其中 foo 的行为是不确定的，可能导致不安全问题的发生，被称之为**外星方法**。因为foo方法可以被重写，导致线程不安全。在String类的设计就考虑到了这一点，String类是`final`的，子类不能重写它的方法。

```java
    public void foo(SimpleDateFormat sdf) {
        String dateStr = "1999-10-11 00:00:00";
        for (int i = 0; i < 20; i++) {
            new Thread(() -> {
                try {
                    sdf.parse(dateStr);
                } catch (ParseException e) {
                    e.printStackTrace();
                }
            }).start();
        }
    }
```

**示例8**：

```java
@Slf4j
public class Test {
    private static Integer i = 0;

    public static void main(String[] args) throws InterruptedException {
        List<Thread> list = new ArrayList<>();
        for (int j = 0; j < 2; j++) {
            Thread thread = new Thread(() -> {
                for (int k = 0; k < 5000; k++) {
                    synchronized (i) {
                        // 是否安全？否。
                        i++;
                    }
                }
            }, "" + j);
            list.add(thread);
        }
        list.stream().forEach(t -> t.start());
        list.stream().forEach(t -> {
            try {
                t.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        log.debug("{}", i);
    }
}
```

## 
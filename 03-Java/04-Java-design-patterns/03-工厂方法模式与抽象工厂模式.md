**问题引出**

假如有一个披萨店，Pizza的种类有很多，如CheesePizza、VeggiePizza、PepperPizza等。披萨店根据收到的订单制作Pizza，披萨的制作流程有材料的准备材料、烤、切、包装几步。如何设计Pizza的订购呢？按照一般的设计思路：

<img src="https://img-blog.csdnimg.cn/20201207143630863.png" style="zoom:80%;" />

其中订购功能：

```java
    Pizza OrderPizza(String orderType) {
        Pizza pizza;

        if (orderType.equals("veggie")) {
            pizza = new VeggiePizza();
            pizza.setName("素食披萨");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨 ");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        
        // pizza制作过程
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
```

然而当披萨店增加或者删除披萨类型时，必须修改OrderPizza的代码。例如想要添加一个“中国披萨”，那么就要添加：

```java
        else if (orderType.equals("china")) {
            pizza = new ChinaPizza();
            pizza.setName("中国披萨");
        }
```

也就是说，只要子类有增减，这段代码就得一改再改。这种设计明显违反了“开放-关闭原则”，并没有做到对修改“关闭”。如何优化呢？这里得引出“简单工厂模式”了。

# 1 简单工厂

## 1.1 定义

**简单工厂模式(Simple Factory Pattern)**：又称为**静态工厂方法(Static Factory Method)模式**，简单工厂模式中专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

简单工厂模式并**不在 GoF 23 种设计模式之列，与其说其是设计模式，不如说是一种编程习惯**。

## 1.2 结构

简单工厂模式包含如下角色：

- Factory：工厂角色

  工厂角色负责实现创建所有实例的内部逻辑。

- Product：抽象产品角色

  抽象产品角色是所创建的所有对象的父类，负责描述所有实例所共有的公共接口。

- ConcreteProduct：具体产品角色

  具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例。

![../_images/SimpleFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/SimpleFactory.jpg)

简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化，这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。

**时序图**

![../_images/seq_SimpleFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_SimpleFactory.jpg)

## 1.3 实现

还是以上面的披萨店为例。以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。

```java
public class SimpleFactory {
    public Pizza createPizza(String orderType) {
        Pizza pizza = null;

        System.out.println("使用简单工厂模式");
        if (orderType.equals("veggie")) {
            pizza = new VeggiePizza();
            pizza.setName("素食披萨 ");
        } else if (orderType.equals("cheese")) {
            pizza = new CheesePizza();
            pizza.setName("奶酪披萨 ");
        } else if (orderType.equals("pepper")) {
            pizza = new PepperPizza();
            pizza.setName("胡椒披萨");
        }
        return pizza;
    }
}
```

客户代码修改为：

```java
public PizzaStore{
    SimpleFactory simpleFactory;
    
    public OrderPizza(SimpleFactory simpleFactory) {
        setFactory(simpleFactory);
    }
    
	public Pizza orderPizza(String orderType) {
        Pizza pizza;
        
        pizza = simpleFactory.createPizza(orderType);
        
        pizza.prepare();
        pizza.bake();
        pizza.cut();
        pizza.box();
        return pizza;
    }
    
    // 其他方法
}
```

## 1.4 总结

**优点**

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

**缺点**

- 由于工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- 系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。

**适用场景**

在以下情况下可以使用简单工厂模式：

- 工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。
- 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

**应用场景**

1. JDK类库中广泛使用了简单工厂模式，如工具类java.text.DateFormat，它用于格式化一个本地日期或者时间。

```
public final static DateFormat getDateInstance();
public final static DateFormat getDateInstance(int style);
public final static DateFormat getDateInstance(int style,Locale locale);
```

2. Java加密技术

获取不同加密算法的密钥生成器:

```
KeyGenerator keyGen=KeyGenerator.getInstance("DESede");
```

创建密码器:

```java
Cipher cp=Cipher.getInstance("DESede");
```

# 2 工厂方法(Factory Method)

## 2.1 定义

**工厂方法模式(Factory Method Pattern)**又称为工厂模式，也叫**虚拟构造器(Virtual Constructor)模式**或者**多态工厂(Polymorphic Factory)模式**，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。

## 2.2 结构

工厂方法模式由抽象工厂、具体工厂、抽象产品和具体产品等4个要素构成。

* 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。

* 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。

* 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。

* 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

![../_images/FactoryMethod.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/FactoryMethod.jpg)

**时序图**

![../_images/seq_FactoryMethod.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_FactoryMethod.jpg)

## 2.3 实现

## 2.4 总结

**优点**

**缺点**

**适用场景**

# 3 抽象工厂(Abstract Factory)

## 3.1 定义

抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

## 3.2 结构

抽象工厂模式同工厂方法模式一样，也是由抽象工厂、具体工厂、抽象产品和具体产品等 4 个要素构成，但抽象工厂中方法个数不同，抽象产品的个数也不同。现在我们来分析其基本结构和实现方法。

抽象工厂模式包含如下角色：

- AbstractFactory：抽象工厂
- ConcreteFactory：具体工厂
- AbstractProduct：抽象产品
- Product：具体产品

![../_images/AbatractFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/AbatractFactory.jpg)

**时序图**

![../_images/seq_AbatractFactory.jpg](https://design-patterns.readthedocs.io/zh_CN/latest/_images/seq_AbatractFactory.jpg)

## 3.3 实现

## 3.4 总结

**优点**

**缺点**

**适用场景**

# 参考

* 《Head First设计模式》
* [软件设计模式概述](http://c.biancheng.net/view/1317.html)
* [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html#)

